\section{Introduction to HoTT}
\subauthor{Paige Randall North}{Utrecht University}
\plquote{``Learning math from Wikipedia is like learning a language from a dictionary.''}

\subsection{Overview}
Homotopy type theory sits at the intersection of type theory, logic, set theory,
category theory and more. It is a branch of Martin-L\"of Type Theory (herefore MLTT),
which itself is closely related to the Calculus of Inductive Constructions.

HoTT has three basic judgements:
\begin{itemize}
\item $\Gamma \ctx$ is a judgement
\item If $\Gamma \ctx$, then $\Gamma \vdash T \ty$
\item If $\Gamma \vdash T \ty$, then $\gamma \vdash t : T$
\end{itemize}

We have three corresponding wquality judgements: context equality, type
equality and term equality.

We have type formers: 
\begin{itemize}
\item $\emptyset, \mathrm{unit}, \bool, \N$ which are $W$-types (inductive types).
\item $=$ types (like \lstinline{eq_refl} in Coq).\footnote{This is not exactly a $W$-type, but what's called an \emph{indexed dependent $W$-type}.}
\item $\Sigma$ types, $\Pi$ types.
\item Hierarchy $U_i$ of universe types.
\end{itemize}

\textbf{Univalent type theory foundations}: MLTT + the univalence axiom. Emphasizes h-levels (homotopy levels).

\textbf{Homotopy type theory}: UTT + higher inductive types.

\subsection{Inductive Types}

Inductive types are generated by \emph{canonical terms}. For example, if we have the following type in Coq:
\begin{lstlisting}
Inductive T : Type :=
| 0 : T
| 1 : T
\end{lstlisting}
Then $0, 1$ are the canonical terms.
Specifically, we have to specify the behavior in four ways, and Coq generates two of them implicitly:
\begin{itemize}
\item Formation rule.
\item Introduction rule (canonical terms).
\item Elimination rule (induction principle). Automatically generated.
\item Computation rule ($\beta$-reduction). Automatically generated.
\end{itemize}

For example, for $\bool$, we have the following judgements:
\[
\begin{array}{lc}
\text{formation} & \frac{}{\vdash \bool : \ty} \\
\text{introduction} &\frac{}{\vdash \mathrm{true} : \bool} \\
\text{introduction} & \frac{}{\vdash \mathrm{false} : \bool} \\
\text{elimination} & \frac{\Gamma, x : \bool \vdash D(x) \ty~~~~\Gamma \vdash a : D(\mathrm{true})~~~~\Gamma \vdash
b : D(\mathrm{false})}{\Gamma, x : \bool \vdash \mathrm{ind}_\bool (a, b, x) : D(x)} \\
\text{computation} & \frac{\Gamma, x : \bool \vdash D(x) \ty~~~~\Gamma \vdash a : D(\mathrm{true})~~~~\Gamma \vdash
b : D(\mathrm{false})}{\Gamma, x : \bool \vdash \mathrm{ind}_\bool (a, b, \mathrm{true}) = a : D(\mathrm{true})~~~~
\Gamma, x : \bool \vdash \mathrm{ind}_\bool (a, b, \mathrm{false}) = a : D(\mathrm{false})}
\end{array}
\]

\noindent For $\N$, we have the following judgements:
\[
\begin{array}{lc}
\text{formation} & \frac{}{\vdash \N : \ty} \\
\text{introduction} &\frac{}{\vdash 0 : \N} \\
\text{introduction} & \frac{\Gamma \vdash n : \N}{\Gamma \vdash sn : \N} \\

\text{elimination} & \frac{\Gamma, n : \N \vdash D(n) \ty~~~~
\Gamma \vdash a : D(\mathrm{0})~~~~
\Gamma, x : \N, y : D(x)\vdash
b : D(sx)}{\Gamma, x : \N \vdash \mathrm{ind}_\N (a, b, x) : D(x)} \\

\text{computation} & \frac{\Gamma, x : \N \vdash D(x) \ty~~~~
\Gamma \vdash a : D(0)~~~~
\Gamma, x : \N, y : D(x) \vdash b : D(\mathrm{sx})}
{\Gamma, x : \N \vdash \mathrm{ind}_\N (a, b, 0) = a : D(0)~~~~
\Gamma, x : \N \vdash \mathrm{ind}_\N (a, b, sx) = b[\mathrm{ind}_\N (a, b, x)/y] : D(sx)}
\end{array}
\]

\noindent For example, we can define the type of $\vdash \mathrm{add} : \N \to \N \to \N$:
\begin{alignat*}{2}
% \setstretch{2}
% \begin{array}{c}
\frac{\frac{\vdash \lambda n. n : \N \to \N~~~~n: \N, h : \N \to \N \vdash sh : \N \to \N}
{n: \N \vdash ? : \N \to \N}}{\vdash \lambda n. ? : \N \to \N \to \N}
% \end{array}
\end{alignat*}
Where by $sh$ we really mean $\lambda n. shn$. This is a lot like using Coq tactics
like \lstinline{intro(s)} and \lstinline{induction}. 

We can also define dependent pair types ($\Sigma$ types), which contain pairs of an element
and a type:
\[
\begin{array}{lc}
\text{formation} & \frac{\Gamma, x : P \vdash Q(x) \ty}{\Gamma \vdash \Sigma_{x: P} Q(x) \ty} \\
\text{introduction} & \frac{\Gamma \vdash p : P~~~~\Gamma \vdash q: Q(x)}{\Gamma \vdash \langle p, q \rangle : \Sigma_{x : P} Q(x)} \\

\text{elimination} & \frac{\Gamma, z : \Sigma_{x: P} Q(x) \vdash D(z) \ty~~~~
\Gamma \vdash x: P, y : Q(x)\vdash
a : D(\langle x, y \rangle)}
{\Gamma, z : \Sigma_{x : P} Q(x) \vdash \mathrm{ind}_\Sigma (a, z) : D(z)} \\

\text{computation} & \frac{\Gamma, z : \Sigma_{x: P} Q(x) \vdash D(z) \ty~~~~
\Gamma, x : P, y : D(x) \vdash a : D(\langle x, y \rangle)}
{\Gamma, x : P, y : Q(x) \vdash \mathrm{ind}_\Sigma (a, \langle x, y \rangle) = a : D(\langle x, y\rangle)}
\end{array}
\]

Basically this should be read as a tagged union of types.

\subsection{Types as Logic}
We remind ourselves of the Curry-Howard Correspondence and the Brouwer-Heyting-Kolmogorov Correspondence:
\[
\begin{array}{cccc}
\underbar{Types} & \underbar{Logic} & \underbar{Sets} & \underbar{Programs} \\
\Gamma \text{~ctx} & \text{Hypotheses} & \text{Indexing sets} & \text{Names in scope} \\
\Gamma \vdash T \ty & \text{Proposition} & \text{Indexed set} & \text{Program specification} \\
\Gamma \vdash t : T & \text{Proof} &\text{Elements} & \text{Program} \\
\N & - & \N & \text{Collection of programs returning a natural number} \\
\text{Sum types} & \text{Disjunction} & \text{Unions} & \text{Specification disjunction} \\
\text{Function types} & \text{Implication} & \text{Set exponentiation~}T^S & \text{Reductions} \\
\Sigma_{x: P} E(x) & \exists & \text{Infinite unions} & \exists \\
\Pi_{x: P} E(x) & \forall & \text{Choice} & \forall
\end{array}
\]

In particular, proving propositions in type systems requires constructing a term of the appropriate type.

We will specifically consider the equality/identity type $=$. Why is it interesting?
\begin{itemize}
\item Some equalities hold only propositionally and not directly from definition: for example, it's easy
to prove $add x 0 = x$, what about $add 0 x = x$?
\item Proving equalities would mean producing a value of the appropriate type.
\item Type formers often internalize structure.
\end{itemize}

The definition of the identity type:
\[
\begin{array}{lc}
\text{formation} & \frac{\Gamma \vdash a: A~~~~\Gamma \vdash b : A}{\Gamma \vdash a =_A b \ty} \\
\text{introduction} & \frac{\Gamma~~~~\Gamma \vdash a: A}{\Gamma \vdash r_a : a =_A a} \\

\text{elimination} & \frac{x : A, y: A, p : x =_A y \vdash D(x, y, p) \ty~~~~\Gamma, x : A \vdash d : D(x, x, r_x)}
{\Gamma, x : A, y : A, p : x =_A y \vdash \mathrm{ind}_= (d, x, y, z) : D(x, y, z)} \\

\text{computation} & \frac{x : A, y: A, p : x =_A y \vdash D(x, y, p) \ty~~~~\Gamma, x : A \vdash d : D(x, x, r_x)}
{\Gamma, x : A \vdash \mathrm{ind}_= (d, x, x, z) = d : D(x, x, r_x)}
\end{array}
\]

The identity type is reflexive (by construction), symmetric and transitive (can be proven). There
may be multiple terms in the identity type. Crucially, this is how \emph{homotopies} in space
behave. \todo{I fell asleep from space interpretations to univalence.}